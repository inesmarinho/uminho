-- ========================================================================== --
-- Programação Funcional                                            2017/2018 --
-- Ficha 5: Listas por compreensão e optimização com tupling e acumuladores   --
-- ========================================================================== --

module Ficha_5 where
import Data.Char

--------------------------------------------------------------------------------
-- Exercício 1 --
--------------------------------------------------------------------------------

-- (a)
a1 = [x | x <- [1..20], mod x 2 == 0, mod x 3 == 0]

-- (b)
b1 = [x | x <- [y | y <- [1..20], mod y 2 == 0], mod x 3 == 0]

-- (c)
c1 = [(x,y) | x <- [0..20], y <- [0..20], x+y == 30]

-- (d)
d1 = [sum [y | y <- [1..x], odd y] | x <- [1..10]]

--------------------------------------------------------------------------------
-- Exercício 2 --
--------------------------------------------------------------------------------

-- (a)
a2 = [2^e | e <- [0..10]]

-- (b)
b2 = [(x,y) | x <- [1..5], y <- [1..5], x+y==6]

b22 = [(x,6-x) | x <- [1..5]]

-- (c)
c2 = [[1..x] | x <- [1..5]]

-- (d)
d2 = [replicate x 1 | x <- [1..5]]

-- extra
inits l = [take n l | n <- [0..length l]]

--------------------------------------------------------------------------------
-- Exercício 3 --
--------------------------------------------------------------------------------

digitAlpha :: String -> (String, String)
digitAlpha [] = ([],[])
digitAlpha (h:t) | isDigit h = (h:ld,la)
                 | isAlpha h = (ld,h:la)
                 | otherwise = (ld,la)
               where
                  (ld,la) = digitAlpha t

--------------------------------------------------------------------------------
-- Exercício 4 --
--------------------------------------------------------------------------------

nzp :: [Int] -> (Int,Int,Int)
nzp [] = (0,0,0)
nzp (h:t) | h >  0 = (n,z,p+1)
          | h == 0 = (n,z+1,p)
          | h <  0 = (n+1,z,p)
        where
          (n,z,p) = nzp t

--------------------------------------------------------------------------------
-- Exercício 5 --
--------------------------------------------------------------------------------

divMod :: Integral a => a -> a -> (a, a)
divMod a b = undefined

--------------------------------------------------------------------------------
-- Exercício 6 --
--------------------------------------------------------------------------------

fromDigits :: [Int] -> Int
fromDigits [] = 0
fromDigits l = fst (fromDigitsAux l)

fromDigitsAux :: [Int] -> (Int, Int)
fromDigitsAux [] = (0,0)
fromDigitsAux (h:t) = (h*10^e+r,e+1)
                   where
                     (r,e) = fromDigitsAux t
