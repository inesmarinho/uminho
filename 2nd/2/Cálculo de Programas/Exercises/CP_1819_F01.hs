-- ========================================================================= --
-- Cálculo de Programas                                            2018/2019 --
-- Ficha 1: Revisões de Programação Funcional                                --
-- ========================================================================= --
module Ficha_1 where

import CP
import Data.Maybe

-------------------------------------------------------------------------------
-- Exercício 2 --
-------------------------------------------------------------------------------

length' :: [a] -> Int
length' [] = 0
length' (x:xs) = 1 + length' xs

reverse' :: [a] -> [a]
reverse' [] = []
reverse' (x:xs) = reverse' xs ++ [x]

-------------------------------------------------------------------------------
-- Exercício 3 --
-------------------------------------------------------------------------------

catMaybes' :: [Maybe a] -> [a]
catMaybes' = map fromJust . filter isJust

-------------------------------------------------------------------------------
-- Exercício 4 --
-------------------------------------------------------------------------------

uncurry' :: (a -> b -> c) -> (a,b) -> c
uncurry' f (x, y) = f x y

curry' :: ((a,b) -> c) -> a -> b -> c
curry' f x y = f (x, y)

flip' :: (a -> b -> c) -> b -> a -> c
flip' f y x = f x y

-------------------------------------------------------------------------------
-- Exercício 5 --
-------------------------------------------------------------------------------

data LTree a = Leaf a
             | Fork (LTree a, LTree a)

flatten :: LTree a -> [a]
flatten (Leaf a) = [a]
flatten (Fork (x, y)) = flatten x ++ flatten y

mirror :: LTree a -> LTree a
mirror (Leaf a) = Leaf a
mirror (Fork (x, y)) = Fork (mirror y, mirror x)

fmap' :: (b -> a) -> LTree b -> LTree a
fmap' f (Leaf b) = Leaf (f b)
fmap' f (Fork (x, y)) = Fork (fmap' f x, fmap' f y)

-------------------------------------------------------------------------------
-- Exercício 6 --
-------------------------------------------------------------------------------

-- (a)

length'' :: [a] -> Int
length'' = foldr (\_ -> (+) 1) 0

-- (b)

-- identidade = foldr (:) []

-------------------------------------------------------------------------------
-- Exercício 7 --
-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
-- Exercício 8 --
-------------------------------------------------------------------------------

function8 :: [Int] -> [Int]
function8 s = [a + 1 | a <- s, a > 0 ]

succPositives :: [Int] -> [Int]
succPositives = map succ . filter (0<)

-------------------------------------------------------------------------------
-- Exercício 9 --
-------------------------------------------------------------------------------

-- (a)

map' :: (a -> b) -> [a] -> [b]
map' f = foldr ((:) . f) []

-- (b)

-- (c)

-- (d)
